% Measures the bias in the visual discrimination task over time. Can take
% more than one session in tData and averages the behabior across
% sessions. Averaging is based on session number and not on the time at
% which the trial occured.
% 
% @INPUTS
%   tData: struct containing behavioral data. Generated by processTaskDataDurable
%   type: Type of bias to measure. 
%       equalProb: Compute the delay at which a choice of left/right target
%           is equally probable
%       0Delay: Compute the probability of choosing the left target when
%         the targets appear at the same time
%       Both: Compute and return both (note, I almost always do it this way
%         now and I am not certain that there wouldn't be an error with the
%         other two.)
%    windowSize: How many trials at each delay to include in each time
%       point. A warning is generated if the expected number of trials is
%       not found within a block. This code assumes that tData has been
%       scrubbed of any trials in which no choice is made or in which the
%       delay was wrong. 
%   x0: Optional (if it is not included than the output y is not
%      generated). x0 is the delay at which to return the probability of
%      choosing the left target. x0 is usually the delay at which both
%      targets were equally likely before the sonication.
%   startBlock: Block at which to start processing. Optional. Defaults to
%       0.
% 
% @OUTPUTS
%   time: The time at which each block of trials begins
%   p50: The delay at which a choice of either target is equally probable.
%   y: The probability of picking the left target at the delay x0. If x0 is
%       not included then y is not computed.
%   m_0: The average probability of chossing the left target when both
%      targets appear at the same time
%   ch
function [time,p50,y,m0,ch,pIdx] = behaviorOverTimeBlocks(tData,nBlocks,x0,startBlock)

if ~exist('startBlock','var')
    startBlock = 0;
end

if length(tData)>1
    error('Too many tData structs. This function is meant to process one session at a time.')
end

%% Figure out how many trials per delay in a block
trialsPerBlock= zeros(size(tData));
for ii = 1:length(tData)
    trialsPerBlock(ii) = tData(ii).trialsPerBucket;
end
trialsPerBlock = unique(trialsPerBlock);
if length(trialsPerBlock) > 1
    error('Different runs have a different number of trials per block. I don''t know how to combine them.')
end

%% Figure out how many different delays we need to deal with
% Set delay vector
delay = unique(tData.delay);
if length(delay) > 5
    delay = unique(tData.delay(150:end));
    warning('Removing early delays.');
    if length(delay)>5
        error('Too many delays');
    end
end


jj = 1;
dataRemains = 1;
overlappingWindows = 1;
windowSize = nBlocks*trialsPerBlock;
while dataRemains
    % Find index for current set of trials
    curCh = nan(length(delay),1);
    if overlappingWindows
        curBlocks = ((jj-1):(jj-1+nBlocks-1))+startBlock;
    else
        curBlocks = (((jj-1)*nBlocks):(jj*nBlocks-1))+startBlock;
    end
    curIdx = find(ismember(tData.Block,curBlocks));

    if length(curIdx)<windowSize*length(delay)
        dataRemains = 0;
        continue;
    else
        for kk = 1:length(delay)
            if sum(tData.delay(curIdx)==delay(kk))~=windowSize
                wlabel = [];
                for ll = 1:length(delay)
                    wlabel = [wlabel,', ', num2str(sum(tData.delay(curIdx)==delay(ll)))];
                end
                warning(['Wrong number of delays. BlockNo: ', num2str(jj),'. # Delays: ', wlabel]);
            end
            if sum(~tData.correctDelay(curIdx))
                warning(['Removing ', num2str(sum(~tData.correctDelay(curIdx))), ' trials for incorrect delay.'])
            end
            curIdx = curIdx(logical(tData.correctDelay(curIdx)));
            
            curCh(delay(kk)==delay) = mean(tData.ch(curIdx(tData.delay(curIdx)==delay(kk))));
            dataRemains = 1;
        end
        time(jj) = tData.timing(curIdx(1)).startTime;
        
        % Compute y and p50 for individual sessions
        sigCh = curCh;
        sigDelay = delay(~isnan(sigCh));
        sigCh = sigCh(~isnan(sigCh));
        [slope, bias, downshift, scale] = fitSigmoid(sigDelay, sigCh);
        p50(jj) = equalProbabilityPoint(slope,bias,downshift,scale);

        if exist('x0','var')
            if ~isempty(x0)
                y(jj) = sigmoid_ext(x0,slope,bias,downshift,scale);
            end
        end

        m0(jj) = curCh(delay==0);
    end
    ch(:,jj) = curCh;
    pIdx(jj) = curIdx(1);
    jj = jj+1;
end
if ~exist('p50','var')
    time = nan;
    p50 = nan;
    y = nan;
    m0 = nan;
    ch = nan;
    pIdx = nan;
end