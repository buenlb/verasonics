% Measures the bias in the visual discrimination task over time. Can take
% more than one session in tData and averages the behabior across
% sessions. Averaging is based on session number and not on the time at
% which the trial occured.
% 
% @INPUTS
%   tData: struct containing behavioral data. Generated by processTaskDataDurable
%    windowSize: How many trials at each delay to include in each time
%       point. A warning is generated if the expected number of trials is
%       not found within a block. This code assumes that tData has been
%       scrubbed of any trials in which no choice is made or in which the
%       delay was wrong. 
%   x0: Optional (if it is not included than the output y is not
%      generated). x0 is the delay at which to return the probability of
%      choosing the left target. x0 is usually the delay at which both
%      targets were equally likely before the sonication.
%   startBlock: Block at which to start processing. Optional. Defaults to
%       0.
% 
% @OUTPUTS
%   time: The time at which each block of trials begins
%   p50: The delay at which a choice of either target is equally probable.
%   m_0delay: The average probability of chossing the left target when both
%      targets appear at the same time
%   ch
function [time,p50,m_0delay,ch,y,pIdx] = behaviorOverTimeIndividual(tData,nBlocks,x0,startBlock)

if ~exist('startBlock','var')
    startBlock = 0;
end

%% Figure out how many trials per delay in a block
trialsPerBlock= zeros(size(tData));
for ii = 1:length(tData)
    trialsPerBlock(ii) = tData(ii).trialsPerBucket;
end
trialsPerBlock = unique(trialsPerBlock);
if length(trialsPerBlock) > 1
    error('Different runs have a different number of trials per block. I don''t know how to combine them.')
end

%% Figure out how many different delays we need to deal with
totDelays = [];
for ii = 1:length(tData)
        delay = unique(tData(ii).delay);
        totDelays = unique([totDelays;delay]);
end

% time = zeros(size(tData));
% ep = zeros(floor(length(tData(ii).ch)/(windowSize*length(delay))),1);
% m0 = ep;
jj = 1;
dataRemains = 1;
overlappingWindows = 1;
windowSize = nBlocks*trialsPerBlock;
firstIdx = (startBlock+1)*trialsPerBlock*length(delay);
while dataRemains
    curCh = nan(length(totDelays),length(tData));
    if overlappingWindows
        curIdx = firstIdx+(((jj-1)*length(delay)*trialsPerBlock+1):((jj-1)*length(delay)*trialsPerBlock+windowSize*length(delay)));
    else
        curIdx = firstIdx+(((jj-1)*windowSize*length(delay)+1):(jj*windowSize*length(delay)));
    end
    if curIdx(end)>length(tData(ii).delay)
        dataRemains = 0;
        break;
    end
    delay = unique(tData(ii).delay);
    if length(delay) > 5
        delay = unique(tData(ii).delay(150:end));
        warning('Removing early delays.');
        if length(delay)>5
            error('Too many delays');
        end
    end
    for kk = 1:length(delay)
        if sum(tData(ii).delay(curIdx)==delay(kk))~=windowSize
            wlabel = [];
            for ll = 1:length(delay)
                wlabel = [wlabel,', ', num2str(sum(tData(ii).delay(curIdx)==delay(ll)))];
            end
            warning(['Wrong number of delays. BlockNo: ', num2str(jj),'. # Delays: ', wlabel]);
        end
        if sum(~tData(ii).correctDelay(curIdx))
            warning(['Removing ', num2str(sum(~tData(ii).correctDelay(curIdx))), ' trials for incorrect delay.'])
        end
        curIdx = curIdx(logical(tData(ii).correctDelay(curIdx)));
        
        curCh(delay(kk)==totDelays,ii) = mean(tData(ii).ch(curIdx(tData(ii).delay(curIdx)==delay(kk))));
        dataRemains = 1;
    end
    time(jj) = tData(ii).timing(curIdx(1)).startTime;
    
    ch(:,jj) = mean(curCh,2,'omitnan');

    pIdx(jj) = curIdx(1);
   
    sigCh = ch(:,jj);
    sigDelay = totDelays(~isnan(sigCh));
    sigCh = sigCh(~isnan(sigCh));
    [slope, bias, downshift, scale] = fitSigmoid(sigDelay, sigCh);
    ep(jj) = equalProbabilityPoint(slope,bias,downshift,scale);
    m0(jj) = mean(ch(totDelays==0,jj),'omitnan');
    if exist('x0','var')
        y(jj) = sigmoid_ext(x0,slope,bias,downshift,scale);
    end
    jj = jj+1;
end
if ~exist('ep','var')
    warning('Not enough trials after startBlock')
    p50 = nan;
    m_0delay = nan;
    time = nan;
    ch = nan;
    y = nan;
    pIdx = nan;
    return;
end
p50 = ep;
m_0delay = m0;