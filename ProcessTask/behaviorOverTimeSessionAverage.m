% Measures the bias in the visual discrimination task over time. Can take
% more than one session in tData and averages the behabior across
% sessions. Averaging is based on session number and not on the time at
% which the trial occured.
% 
% @INPUTS
%   tData: struct containing behavioral data. Generated by processTaskDataDurable
%   type: Type of bias to measure. 
%       equalProb: Compute the delay at which a choice of left/right target
%           is equally probable
%       0Delay: Compute the probability of choosing the left target when
%         the targets appear at the same time
%       Both: Compute and return both (note, I almost always do it this way
%         now and I am not certain that there wouldn't be an error with the
%         other two.)
%    windowSize: How many trials at each delay to include in each time
%       point. A warning is generated if the expected number of trials is
%       not found within a block. This code assumes that tData has been
%       scrubbed of any trials in which no choice is made or in which the
%       delay was wrong. 
%   x0: Optional (if it is not included than the output y is not
%      generated). x0 is the delay at which to return the probability of
%      choosing the left target. x0 is usually the delay at which both
%      targets were equally likely before the sonication.
%   startBlock: Block at which to start processing. Optional. Defaults to
%       0.
% 
% @OUTPUTS
%   time: The time at which each block of trials begins
%   p50: The delay at which a choice of either target is equally probable.
%   m_0delay: The average probability of chossing the left target when both
%      targets appear at the same time
%   ch
function [time,p50,m_0delay,ch,y,pInd,yInd,m0Ind,pIdx] = behaviorOverTimeSessionAverage(tData,type,nBlocks,x0,startBlock)

if ~exist('startBlock','var')
    startBlock = 0;
end

%% Figure out how many trials per delay in a block
trialsPerBlock= zeros(size(tData));
for ii = 1:length(tData)
    trialsPerBlock(ii) = tData(ii).trialsPerBucket;
end
trialsPerBlock = unique(trialsPerBlock);
if length(trialsPerBlock) > 1
    error('Different runs have a different number of trials per block. I don''t know how to combine them.')
end

%% Figure out how many different delays we need to deal with
totDelays = [];
for ii = 1:length(tData)
        delay = unique(tData(ii).delay);
        totDelays = unique([totDelays;delay]);
end

time = cell(size(tData));
% ep = zeros(floor(length(tData(ii).ch)/(windowSize*length(delay))),1);
% m0 = ep;
jj = 1;
dataRemains = 1;
overlappingWindows = 0;
windowSize = nBlocks*trialsPerBlock;
outOfData = false(size(tData));
while dataRemains
    curCh = nan(length(totDelays),length(tData));
    dataRemains = 0;
    for ii = 1:length(tData)
        if overlappingWindows
            curBlocks = (jj-1):(jj-1+nBlocks-1)+startBlock;
        else
            curBlocks = ((jj-1)*nBlocks):(jj*nBlocks-1)+startBlock;
        end
        curIdx = find(ismember(tData(ii).Block,curBlocks));
        if length(curIdx)<windowSize
            curCh(:,ii) = nan;
            pInd(ii,jj) = nan;
            yInd(ii,jj) = nan;
            m0Ind(ii,jj) = nan;
            outOfData(ii) = true;
            if sum(outOfData)==length(outOfData)
                dataRemains = 0;
            end
            continue;
        else
            delay = unique(tData(ii).delay);
            if length(delay) > 5
                delay = unique(tData(ii).delay(150:end));
                warning('Removing early delays.');
                if length(delay)>5
                    error('Too many delays');
                end
            end
            for kk = 1:length(delay)
                if sum(tData(ii).delay(curIdx)==delay(kk))~=windowSize
                    wlabel = [];
                    for ll = 1:length(delay)
                        wlabel = [wlabel,', ', num2str(sum(tData(ii).delay(curIdx)==delay(ll)))];
                    end
                    warning(['Wrong number of delays. BlockNo: ', num2str(jj),'. # Delays: ', wlabel]);
                end
                if sum(~tData(ii).correctDelay(curIdx))
                    warning(['Removing ', num2str(sum(~tData(ii).correctDelay(curIdx))), ' trials for incorrect delay.'])
                end
                curIdx = curIdx(logical(tData(ii).correctDelay(curIdx)));
                
                curCh(delay(kk)==totDelays,ii) = mean(tData(ii).ch(curIdx(tData(ii).delay(curIdx)==delay(kk))));
                dataRemains = 1;
            end
            time{ii}(jj) = tData(ii).timing(curIdx(1)).startTime;
            
            % Compute y and p for individual sessions
            if strcmp(type,'EqualProb') || strcmp(type,'Both')
                sigCh = curCh(:,ii);
                sigDelay = totDelays(~isnan(sigCh));
                sigCh = sigCh(~isnan(sigCh));
                [slope, bias, downshift, scale] = fitSigmoid(sigDelay, sigCh);
                pInd(ii,jj) = equalProbabilityPoint(slope,bias,downshift,scale);
                if exist('x0','var')
                    yInd(ii,jj) = sigmoid_ext(x0,slope,bias,downshift,scale);
                end
            end
            if strcmp(type,'0Delay') || strcmp(type,'Both')
                m0Ind(ii,jj) = curCh(totDelays==0);
            end
        end
    end
    ch(:,jj) = mean(curCh,2,'omitnan');

    % Compute y and p averaged. Averaging occurs for each delay across
    % sessions.
    pIdx(jj) = curIdx(1);
    if strcmp(type,'EqualProb') || strcmp(type,'Both')
        sigCh = ch(:,jj);
        sigDelay = totDelays(~isnan(sigCh));
        sigCh = sigCh(~isnan(sigCh));
        [slope, bias, downshift, scale] = fitSigmoid(sigDelay, sigCh);
        ep(jj) = equalProbabilityPoint(slope,bias,downshift,scale);
        if exist('x0','var')
            y(jj) = sigmoid_ext(x0,slope,bias,downshift,scale);
        end
    end
    if strcmp(type,'0Delay') || strcmp(type,'Both')
        m0(jj) = mean(ch(totDelays==0,jj),'omitnan');
    end
    jj = jj+1;
end
p50 = ep;
m_0delay = m0;